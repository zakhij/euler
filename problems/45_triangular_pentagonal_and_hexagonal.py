import math

"""
Problem Statement:
Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
Triangle: T_n = n(n + 1) / 2
1, 3, 6, 10, 15, ...
Pentagonal: P_n = n(3n - 1) / 2
1, 5, 12, 22, 35, ...
Hexagonal: H_n = n(2n - 1)
1, 6, 15, 28, 45, ...
It can be verified that T_285 = P_165 = H_143 = 40755.
Find the next triangle number that is also pentagonal and hexagonal.

Computational Analysis: Our program runs in O(n) time, where n is the number of triangular terms we must
iterate across (we perform constant time work per term, though). Space complexity is constant, we don't
use any data containers. 

DSA: This is a brute force operation, iterating across until specific criteria is met.

Math: We leverage algebra in defining the helper validation functions. That's about it.

"""

"""
Program Attempt 1:
I don't see a pattern between the different types of numbers we can exploit, this problem requires
mere brute force: We iterate across triangular numbers, checking for pentagonal-ness and hexagonal-ness.
We can define quick helper functions to perform those checks in constant time. 
x = n(3n-1)/2 --> 1.5n^2 - 0.5n - x = 0 --> n = (1 + sqrt(1+24x))/6
x = n(2n-1) --> 2n^2 - n - x = 0 --> n = (1+ sqrt(1+8x))/4
"""


def is_pentagonal_number(x: int) -> bool:
    return ((1 + math.sqrt(1 + 24 * x)) / 6).is_integer()


def is_hexagonal_number(x: int) -> bool:
    return ((1 + math.sqrt(1 + 8 * x)) / 4).is_integer()


def get_triangular_number(x: int) -> int:
    return int(x * (x + 1) // 2)


def main():
    triangular_base = 286
    while True:
        tri = get_triangular_number(triangular_base)
        if is_hexagonal_number(tri) and is_pentagonal_number(tri):
            print(tri)
            return
        else:
            triangular_base += 1


if __name__ == "__main__":
    main()
