import math

"""
Problem Statement:
Pentagonal numbers are generated by the formula, P_n=n(3n-1)/2. The first ten pentagonal numbers are: 
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 - 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference 
are pentagonal and D = |P_k - P_j| is minimised; what is the value of D?

Computational Analysis: Our solution has a runtime complexity of O(jk), which speaks to the importance of choosing
robust iteration ranges. We can check for a given pair's validity in constant time. The space complexity is also constant.

DSA: Our method utilizes brute-force: iterating across every possible candidate pair in a given range and testing for validity.
No special data structures or algorithms used here. 

Math: Our pair validity check is based on formulating and solving algebraic equations. 

"""

"""
Program Attempt 1:
Ok, let's write down the problem constraints. Need to find valid values of j and k that satisfy
a = P_j + P_k
b = P_j - P_k,
where a = n(3n-1)/2 for some integer n and b = m(3m-1)/2 for some integer m.
By quadratically solving for n and m in the where clause, we can simplify the where clause to:
where (1 + sqrt(1+24a))/6 and (1 + sqrt(1+24b))/6 are both integers.

Ok, cool. We now have a way to test a pair [j, k]. The question is: how should we go about iterating over j and k?
Ideally, we iterate them in such a way that the distance D (defined as P_k - P_j) only increases as we continue iterating,
allowing us to stop the iteration once we find a valid pair. This doesn't come across as intuitive to me. 

Okay, so I got the right answer. I arbitrarily decided to check for k values between j+1 and j+2000 for each value of j, and
iterate j from 1 to 9999. Not sure if there's a mathematically optimal search strategy, but hey, it worked.
"""


def pentagonify_number(x: int) -> int:
    return int(0.5 * x * (3 * x - 1))


def is_pentagonal_number(x: int) -> bool:
    return ((1 + math.sqrt(1 + 24 * x)) / 6).is_integer()


def is_valid_pair(j: int, k: int) -> bool:
    a = pentagonify_number(j) + pentagonify_number(k)
    b = pentagonify_number(k) - pentagonify_number(j)
    return is_pentagonal_number(a) and is_pentagonal_number(b)


def main() -> None:

    min_dist = 99999999
    for j in range(1, 9999):
        for k in range(j + 1, j + 2000):
            if is_valid_pair(j, k):
                print(f"{j} and {k}!")
                if pentagonify_number(k) - pentagonify_number(j) < min_dist:
                    min_dist = pentagonify_number(k) - pentagonify_number(j)

    print(min_dist)


if __name__ == "__main__":
    main()
